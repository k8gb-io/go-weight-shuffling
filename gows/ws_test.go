package gows

/*
Copyright 2022 The k8gb Contributors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
Generated by GoLic, for more details see: https://github.com/AbsaOSS/golic
*/

import (
	"fmt"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestInit(t *testing.T) {
	tests := []struct {
		name  string
		pdf   []int
		valid bool
	}{
		{"happy distribution", []int{30, 40, 20, 10}, true},
		{"90%", []int{50, 40}, false},
		{"No elements ", []int{}, false},
		{"out of range value 1", []int{101, 2}, false},
		{"out of range value 2", []int{30, 40, 20, 10, -10, 10}, false},
		{"zero", []int{0}, false},
		{"hundred", []int{0, 0, 100}, true},
		{"hundred", []int{100, 0}, true},
		{"hundred", []int{100}, true},
		{"50 50 0", []int{50, 50, 0}, true},
		{"50 50 0 0", []int{50, 50, 0, 0}, true},
		{"50 0 50 0", []int{50, 0, 50, 0}, true},
		{"0 50 0 50", []int{0, 50, 0, 50}, true},
		{"50 0 0 50", []int{50, 0, 0, 50}, true},
		{"0 0 50 0 0 50 0 0", []int{0, 0, 50, 0, 0, 50, 0, 0}, true},
	}
	for _, test := range tests {
		t.Run(fmt.Sprintf("%s: %v", test.name, test.pdf), func(t *testing.T) {
			_, err := NewWS(test.pdf)
			if !test.valid {
				require.Error(t, err)
				return
			}
			require.NoError(t, err)
		})
	}
}

func TestPick(t *testing.T) {
	const n = 1000
	tests := []struct {
		name              string
		pdf               []int
		allowedMaxDiffPct int
	}{
		{"happy distribution", []int{30, 40, 20, 10}, 5},
		{"50/50 distribution ", []int{50, 50}, 5},
		{"one element ", []int{100}, 0},
		{"twenty elements", []int{5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5}, 3},
		{"strongly unbalanced", []int{90, 2, 2, 2, 2, 2}, 3},
		{"strongly unbalanced2", []int{1, 99}, 1},
		{"one zero", []int{100, 0}, 0},
		{"multiple zeros", []int{100, 0, 0}, 0},
		{"multiple zeros", []int{0, 100, 0}, 0},
		{"multiple zeros", []int{0, 0, 100}, 0},
		{"50 50 0", []int{50, 50, 0}, 20},
	}

	for _, test := range tests {
		t.Run(fmt.Sprintf("%s: %v", test.name, test.pdf), func(t *testing.T) {
			wrr, err := NewWS(test.pdf)
			require.NoError(t, err)
			result := make([]int, len(test.pdf))
			for i := 0; i < n; i++ {
				idx := wrr.Pick()
				assert.True(t, idx >= 0 && idx < len(test.pdf), "Pick returned index out of range")
				result[idx]++
			}
			sum := sum(result)
			assert.Equal(t, sum, n)
			b := checkAllowedDiff(test.pdf, result, sum, test.allowedMaxDiffPct)
			assert.True(t, b, "crossed maximum allowed diff", result)
		})
	}
}

func TestPickVector(t *testing.T) {
	const n = 1000
	tests := []struct {
		name              string
		pdf               []int
		allowedMaxDiffPct int
	}{
		{"happy distribution", []int{30, 40, 20, 10}, 5},
		{"50/50 distribution ", []int{50, 50}, 5},
		{"one element ", []int{100}, 0},
		{"twenty elements", []int{5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5}, 3},
		{"strongly unbalanced", []int{90, 2, 2, 2, 2, 2}, 2},
		{"one zero", []int{100, 0}, 0},
		{"multiple zeros", []int{100, 0, 0}, 0},
		{"multiple zeros", []int{0, 100, 0}, 0},
		{"multiple zeros", []int{0, 0, 100}, 0},
		{"multiple zeros", []int{0, 0, 0, 100, 0, 0}, 0},
		{"50 50 0", []int{50, 50, 0}, 5},
		{"50 50 0 0", []int{50, 50, 0, 0}, 5},
		{"50 0 50 0", []int{50, 0, 50, 0}, 5},
		{"0 50 0 50", []int{0, 50, 0, 50}, 5},
		{"50 0 0 50", []int{50, 0, 0, 50}, 5},
		{"0 0 50 0 0 50 0 0", []int{0, 0, 50, 0, 0, 50, 0, 0}, 5},
	}
	for _, test := range tests {
		t.Run(fmt.Sprintf("%s: %v", test.name, test.pdf), func(t *testing.T) {
			wrr, err := NewWS(test.pdf)
			require.NoError(t, err)

			result := map[int][]int{}
			for i := 0; i < len(test.pdf); i++ {
				result[i] = make([]int, len(test.pdf))
			}

			for i := 0; i < n; i++ {

				indexes := wrr.PickVector(KeepIndexesForZeroPDF)
				for _, v := range indexes {
					assert.True(t, v >= 0 && v < len(test.pdf), "Pick returned index out of range")
				}

				for i := 0; i < len(test.pdf); i++ {
					result[i][indexes[i]]++
				}
			}

			for i := 0; i < len(test.pdf); i++ {
				verticalSum := 0
				horizontalSum := sum(result[i])
				for _, v := range result {
					verticalSum += v[i]
				}
				assert.Equal(t, horizontalSum, n)
				assert.Equal(t, verticalSum, n)
			}
		})
	}
}

func TestSettings(t *testing.T) {
	tests := []struct {
		name                string
		pdf                 []int
		expectedIndexValues []int
		settings            Settings
	}{
		{"happy distribution -Ignore", []int{30, 40, 20, 10}, []int{0, 1, 2, 3}, IgnoreIndexesForZeroPDF},
		{"happy distribution - Keep", []int{30, 40, 20, 10}, []int{0, 1, 2, 3}, KeepIndexesForZeroPDF},

		{"one element  - Ignore", []int{100}, []int{0}, 0},
		{"one element  - Keep", []int{100}, []int{0}, 0},

		{"one zero - Ignore", []int{100, 0}, []int{0}, IgnoreIndexesForZeroPDF},
		{"one zero - Keep ", []int{100, 0}, []int{0, 1}, KeepIndexesForZeroPDF},
		{"0 100 0 - Ignore", []int{0, 100, 0}, []int{1}, IgnoreIndexesForZeroPDF},
		{"0 100 0 - Keep ", []int{0, 100, 0}, []int{0, 1, 2}, KeepIndexesForZeroPDF},

		{"0 50 0 50 - Ignore ", []int{0, 50, 0, 50}, []int{1, 3}, IgnoreIndexesForZeroPDF},
		{"0 50 0 50 - Keep ", []int{0, 50, 0, 50}, []int{0, 1, 2, 3}, KeepIndexesForZeroPDF},

		{"0 0 50 0 0 50 0 0 - Ignore", []int{0, 0, 50, 0, 0, 50, 0, 0}, []int{2, 5}, IgnoreIndexesForZeroPDF},
		{"0 0 50 0 0 50 0 0 - Keep", []int{0, 0, 50, 0, 0, 50, 0, 0}, []int{0, 1, 2, 3, 4, 5, 6, 7}, KeepIndexesForZeroPDF},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			wrr, err := NewWS(test.pdf)
			require.NoError(t, err)
			for x := 0; x < 2; x++ {
				indexes := wrr.PickVector(test.settings)
				assert.True(t, containsValues(indexes, test.expectedIndexValues), "%v %v", indexes, test.expectedIndexValues)
			}
		})
	}
}

// slice a contains same values as defined in slice b.
// the values could be in different order but must be present in both slices
func containsValues(a, b []int) bool {
	if len(a) != len(b) {
		return false
	}
	m := make(map[int]int, len(a))
	for i := 0; i < len(a); i++ {
		m[a[i]]++
		m[b[i]]++
	}
	for _, v := range m {
		if v != 2 {
			return false
		}
	}
	return true
}

func sum(result []int) (sum int) {
	for _, v := range result {
		sum += v
	}
	return sum
}

// checks if result is in allowed diff Â±diffPercent%
func checkAllowedDiff(pdf, result []int, sum int, diffPercent int) bool {
	for i, p := range pdf {
		var pct = float64(p) / 100
		var diff = (float64(diffPercent) / 100) * float64(sum)
		var base = pct * float64(sum)

		if float64(result[i]) > base+diff || float64(result[i]) < base-diff {
			return false
		}
	}
	return true
}

//func TestPrintMatrix(t *testing.T) {
//	pdf := []int{50,50}
//	wrr, err := NewWS(pdf)
//	if err != nil {
//		fmt.Println("ERROR:", err)
//		return
//	}
//	result := map[int][]int{}
//	for i := 0; i < len(pdf); i++ {
//		result[i] = []int{0, 0, 0, 0}
//	}
//
//	for i := 0; i < 1000; i++ {
//		indexes := wrr.PickVector()
//		fmt.Println(indexes)
//		for q := 0; q< len(pdf); q++ {
//			result[q][indexes[q]]++
//		}
//	}
//
//	fmt.Printf("    [10.0.0.1],[10.1.0.1],[10.2.0.1],[10.3.0.1]\n")
//	fmt.Printf("    %v\n", pdf)
//	fmt.Printf("    -----------------\n")
//	for i := 0; i < len(pdf); i++ {
//		fmt.Printf(" %v. %v \n", i, result[i])
//	}
//}
