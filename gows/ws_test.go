package gows

/*
Copyright 2022 The k8gb Contributors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
Generated by GoLic, for more details see: https://github.com/AbsaOSS/golic
*/

import (
	"fmt"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestPick(t *testing.T) {
	const n = 10000
	const diffPercentage = 3
	tests := []struct {
		name               string
		portions           []uint32
		valid              bool
		expectedPercentage []int
	}{
		{"happy distribution", []uint32{30, 40, 20, 10}, true, []int{30, 40, 20, 10}},
		{"-", []uint32{}, false, []int{}},
		{"0", []uint32{0}, false, []int{100}},
		{"0-0-0-0", []uint32{0, 0, 0, 0}, false, []int{}},
		{"50-40", []uint32{50, 40}, true, []int{56, 44}},
		{"50-50", []uint32{50, 50}, true, []int{50, 50}},
		{"1-1", []uint32{1, 1}, true, []int{50, 50}},
		{"50-40-50-40", []uint32{50, 40, 50, 40}, true, []int{29, 22, 27, 22}},
		{"2-1", []uint32{2, 1}, true, []int{66, 33}},
		{"2-1-1", []uint32{2, 1, 1}, true, []int{50, 25, 25}},
		{"1-99", []uint32{1, 99}, true, []int{1, 99}},
		{"1-999 (1)", []uint32{1, 999}, true, []int{0, 99}},
		{"1-999 (2)", []uint32{1, 999}, true, []int{1, 99}},
		{"1-0-0-0", []uint32{1, 0, 0, 0}, true, []int{100, 0, 0, 0}},
		{"0-2-2-0", []uint32{0, 2, 2, 0}, true, []int{0, 50, 50, 0}},
		{"100-0-0-0", []uint32{100, 0, 0, 0}, true, []int{100, 0, 0, 0}},
		{"100-0-0-100", []uint32{100, 0, 0, 100}, true, []int{50, 0, 0, 50}},
		{"900-0-0-100", []uint32{900, 0, 0, 100}, true, []int{90, 0, 0, 10}},
		{"0-1-2-3-4-5-6-7-8-9", []uint32{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}, true, []int{0, 2, 4, 6, 8, 11, 13, 15, 17, 20}},
		{"1-1-1-1-1-1-1-1-1-1-1-1-1-1-1-1-1-1-1-1", []uint32{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}, true,
			[]int{5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5}},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			x := New(test.portions)
			result := make([]int, len(test.portions))
			for i := 0; i < n; i++ {
				index, err := x.Pick()
				if err != nil {
					require.Error(t, err)
					return
				}
				require.NoError(t, err)
				result[index]++
			}
			r := n / 100
			for i := 0; i < len(result); i++ {
				b := closeTo(result[i], test.expectedPercentage[i]*r, n, 3)
				require.True(t, b, "portions %v having expected %v is not equal to  calculated %v with %d%% allowed diff",
					test.portions, test.expectedPercentage, result, diffPercentage)
			}
		})
	}
}

func TestPickVector(t *testing.T) {
	const n = 10000
	tests := []struct {
		name              string
		pdf               []uint32
		allowedMaxDiffPct int
	}{
		{"happy distribution", []uint32{30, 40, 20, 10}, 5},
		{"-", []uint32{}, 5},
		{"0", []uint32{0}, 5},
		{"0-0-0-0", []uint32{0, 0, 0, 0}, 5},
		{"50-50 ", []uint32{50, 50}, 5},
		{"100 ", []uint32{100}, 0},
		{"twenty elements", []uint32{5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5}, 3},
		{"strongly unbalanced", []uint32{90, 2, 2, 2, 2, 2}, 2},
		{"one zero", []uint32{100, 0}, 0},
		{"multiple zeros", []uint32{100, 0, 0}, 0},
		{"multiple zeros", []uint32{0, 100, 0}, 0},
		{"multiple zeros", []uint32{0, 0, 100}, 0},
		{"multiple zeros", []uint32{0, 0, 0, 100, 0, 0}, 0},
		{"50 50 0", []uint32{50, 50, 0}, 5},
		{"50 50 0 0", []uint32{50, 50, 0, 0}, 5},
		{"50 0 50 0", []uint32{50, 0, 50, 0}, 5},
		{"0 50 0 50", []uint32{0, 50, 0, 50}, 5},
		{"50 0 0 50", []uint32{50, 0, 0, 50}, 5},
		{"3 3 0", []uint32{3, 3, 0}, 5},
		{"4 4 0 0", []uint32{4, 4, 0, 0}, 5},
		{"5 0 5 0", []uint32{5, 0, 5, 0}, 5},
		{"0 60 0 60", []uint32{0, 6, 0, 6}, 5},
		{"99999 0 0 99999", []uint32{99999, 0, 0, 99999}, 5},
		{"0 0 50 0 0 50 0 0", []uint32{0, 0, 50, 0, 0, 50, 0, 0}, 5},
		{"0 0 1 0 0 1 0 0", []uint32{0, 0, 50, 0, 0, 50, 0, 0}, 5},
	}
	for _, test := range tests {
		t.Run(fmt.Sprintf("%s: %v", test.name, test.pdf), func(t *testing.T) {
			wrr := New(test.pdf)

			result := map[int][]int{}
			for i := 0; i < len(test.pdf); i++ {
				result[i] = make([]int, len(test.pdf))
			}

			for i := 0; i < n; i++ {

				indexes := wrr.PickVector(IncludeZeroWeights)
				for _, v := range indexes {
					assert.True(t, v >= 0 && v < len(test.pdf), "Pick returned index out of range")
				}

				for i := 0; i < len(test.pdf); i++ {
					result[i][indexes[i]]++
				}
			}

			for i := 0; i < len(test.pdf); i++ {
				verticalSum := 0
				horizontalSum := sum(result[i])
				for _, v := range result {
					verticalSum += v[i]
				}
				assert.Equal(t, horizontalSum, n)
				assert.Equal(t, verticalSum, n)
			}
		})
	}
}

func TestSettings(t *testing.T) {
	tests := []struct {
		name                string
		pdf                 []uint32
		expectedIndexValues []int
		settings            Settings
	}{
		{"happy distribution -Ignore", []uint32{30, 40, 20, 10}, []int{0, 1, 2, 3}, DropZeroWeights},
		{"happy distribution - Keep", []uint32{30, 40, 20, 10}, []int{0, 1, 2, 3}, IncludeZeroWeights},

		{"0  - Ignore", []uint32{0}, []int{}, DropZeroWeights},
		{"0  - Keep", []uint32{0}, []int{0}, IncludeZeroWeights},

		{"0-0-0-0  - Ignore", []uint32{0, 0, 0, 0}, []int{}, DropZeroWeights},
		{"0-0-0-0  - Keep", []uint32{0, 0, 0, 0}, []int{0, 1, 2, 3}, IncludeZeroWeights},

		{"100  - Ignore", []uint32{100}, []int{0}, 0},
		{"100  - Keep", []uint32{100}, []int{0}, 0},

		{"100 0 - Ignore", []uint32{100, 0}, []int{0}, DropZeroWeights},
		{"100 0 - Keep ", []uint32{100, 0}, []int{0, 1}, IncludeZeroWeights},
		{"0 100 0 - Ignore", []uint32{0, 100, 0}, []int{1}, DropZeroWeights},
		{"0 100 0 - Keep ", []uint32{0, 100, 0}, []int{0, 1, 2}, IncludeZeroWeights},

		{"0 50 0 50 - Ignore ", []uint32{0, 50, 0, 50}, []int{1, 3}, DropZeroWeights},
		{"0 50 0 50 - Keep ", []uint32{0, 50, 0, 50}, []int{0, 1, 2, 3}, IncludeZeroWeights},

		{"0 0 50 0 0 50 0 0 - Ignore", []uint32{0, 0, 50, 0, 0, 50, 0, 0}, []int{2, 5}, DropZeroWeights},
		{"0 0 50 0 0 50 0 0 - Keep", []uint32{0, 0, 50, 0, 0, 50, 0, 0}, []int{0, 1, 2, 3, 4, 5, 6, 7}, IncludeZeroWeights},
		{"invalid strategy", []uint32{100, 0}, []int{}, 5},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			wrr := New(test.pdf)
			for x := 0; x < 2; x++ {
				indexes := wrr.PickVector(test.settings)
				assert.True(t, containsValues(indexes, test.expectedIndexValues), "%v %v", indexes, test.expectedIndexValues)
			}
		})
	}
}

func TestIsShuffling(t *testing.T) {
	tests := []struct {
		name              string
		pdf               []uint32
		same              [][]int
		maxDiffPercentage int
		settings          Settings
	}{
		{"50-50",
			[]uint32{50, 50},
			[][]int{{0, 1}, {1, 0}},
			10,
			IncludeZeroWeights,
		},
		{"33-33-34",
			[]uint32{33, 33, 34},
			[][]int{{0, 1, 2}, {0, 2, 1}, {1, 0, 2}, {1, 2, 0}, {2, 1, 0}, {2, 0, 1}},
			25,
			IncludeZeroWeights,
		},
		{"0-100",
			[]uint32{0, 100},
			[][]int{{1, 0}},
			0,
			IncludeZeroWeights,
		},
		{"100-0-0",
			[]uint32{100, 0, 0},
			[][]int{{0, 1, 2}},
			0,
			IncludeZeroWeights,
		},
		{"0-0-100",
			[]uint32{0, 0, 100},
			[][]int{{2, 0, 1}},
			0,
			IncludeZeroWeights,
		},
		{"0-0-100-0",
			[]uint32{0, 0, 100, 0},
			[][]int{{2, 0, 1, 3}},
			0,
			IncludeZeroWeights,
		},
		{"0-50-50",
			[]uint32{0, 50, 50},
			[][]int{{2, 1, 0}, {1, 2, 0}},
			10,
			IncludeZeroWeights,
		},
		{"50-0-50",
			[]uint32{50, 0, 50},
			[][]int{{2, 0, 1}, {0, 2, 1}},
			10,
			IncludeZeroWeights,
		},
		{"50-50-0",
			[]uint32{50, 50, 0},
			[][]int{{0, 1, 2}, {1, 0, 2}},
			10,
			IncludeZeroWeights,
		},
		{"0-50-0-50-0",
			[]uint32{0, 50, 0, 50, 0},
			[][]int{{1, 3, 0, 2, 4}, {3, 1, 0, 2, 4}},
			10,
			IncludeZeroWeights,
		},
		{"50-50-0-50-0",
			[]uint32{33, 33, 0, 34, 0},
			[][]int{{1, 3, 0, 2, 4}, {1, 0, 3, 2, 4}, {0, 1, 3, 2, 4}, {0, 3, 1, 2, 4}, {3, 0, 1, 2, 4}, {3, 1, 0, 2, 4}},
			25,
			IncludeZeroWeights,
		},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			wrr := New(test.pdf)
			counters := make([]int, len(test.same))
			for i := 0; i < 1000; i++ {
				succeed := false
				indexes := wrr.PickVector(test.settings)
				for c, s := range test.same {
					if same(s, indexes) {
						counters[c]++
						succeed = true
					}
				}
				if succeed {
					continue
				}
				t.Fatal("invalid indexes", indexes)
			}
			assert.True(t, nearlyEqual(counters, test.maxDiffPercentage),
				" %v are not nearly equal (expecting max %d%% diff)",
				counters, test.maxDiffPercentage)
		})
	}
}

func TestIsShufflingAsymetric(t *testing.T) {
	const n = 1000
	tests := []struct {
		name               string
		pdf                []uint32
		expectedHits       []int
		maxDiffPercentages int
		settings           Settings
	}{
		{
			"10-90",
			[]uint32{10, 90},
			[]int{100, 900},
			3,
			IncludeZeroWeights,
		},
		{
			"90-5-5",
			[]uint32{90, 5, 5},
			[]int{900, 50, 50},
			3,
			IncludeZeroWeights,
		},
		{
			"30-10-60",
			[]uint32{30, 10, 60},
			[]int{300, 100, 600},
			3,
			DropZeroWeights,
		},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			wrr := New(test.pdf)
			counters := make([]int, len(test.pdf))
			for i := 0; i < n; i++ {
				indexes := wrr.PickVector(test.settings)
				counters[indexes[0]]++
			}
			for i, v := range counters {
				b := closeTo(v, test.expectedHits[i], n, 5)
				assert.True(t, b, "%d is not nearly equal (expecting max %d%% diff) ", v, test.maxDiffPercentages)
			}
		})
	}
}

func closeTo(x, closeTo, max, diff int) bool {
	n := max / 100 * diff
	return x > closeTo-n && x < closeTo+n
}

func nearlyEqual(x []int, diff int) bool {
	var r float64
	for i := 0; i < len(x); i++ {
		r += float64(x[i])
	}
	r = r / float64(len(x))
	da := r * float64(100-diff) / 100
	db := r * float64(100+diff) / 100
	for _, v := range x {
		if float64(v) < da {
			return false
		}
		if float64(v) > db {
			return false
		}
	}
	return true
}

func same(a, b []int) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if a[i] != b[i] {
			return false
		}
	}
	return true
}

// slice a contains same values as defined in slice b.
// the values could be in different order but must be present in both slices
func containsValues(a, b []int) bool {
	if len(a) != len(b) {
		return false
	}
	m := make(map[int]int, len(a))
	for i := 0; i < len(a); i++ {
		m[a[i]]++
		m[b[i]]++
	}
	for _, v := range m {
		if v != 2 {
			return false
		}
	}
	return true
}

func sum(result []int) (sum int) {
	for _, v := range result {
		sum += v
	}
	return sum
}

//func TestPrintMatrix(t *testing.T) {
//	pdf := []int{50,50}
//	wrr, err := New(pdf)
//	if err != nil {
//		fmt.Println("ERROR:", err)
//		return
//	}
//	result := map[int][]int{}
//	for i := 0; i < len(pdf); i++ {
//		result[i] = []int{0, 0, 0, 0}
//	}
//
//	for i := 0; i < 1000; i++ {
//		indexes := wrr.PickVector()
//		fmt.Println(indexes)
//		for q := 0; q< len(pdf); q++ {
//			result[q][indexes[q]]++
//		}
//	}
//
//	fmt.Printf("    [10.0.0.1],[10.1.0.1],[10.2.0.1],[10.3.0.1]\n")
//	fmt.Printf("    %v\n", pdf)
//	fmt.Printf("    -----------------\n")
//	for i := 0; i < len(pdf); i++ {
//		fmt.Printf(" %v. %v \n", i, result[i])
//	}
//}
