package gows

/*
Copyright 2022 The k8gb Contributors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
Generated by GoLic, for more details see: https://github.com/AbsaOSS/golic
*/

import (
	"fmt"
	"math/rand"
	"time"
)

// WS Weight Round Robin Alghoritm
type WS struct {
	pdf                         touples
	filteredPDFFromZeroElements touples
	balance                     int
}

type touples []struct {
	index int
	value int
}

//The Settings argument defines how the PickVector function will return indexes
type Settings int

const (
	// IncludeZeroWeights keeps indexes for zero pdf elements.
	// e.g: for pdf=[0,50,50,0,0,0] may return [1,2,0,3,4,5] or [2,1,0,3,4,5]
	IncludeZeroWeights Settings = iota

	// DropZeroWeights filter indexes for zero pdf elements.
	// e.g: for pdf=[0,50,50,0,0,0] may return [1,2] or [2,1]
	DropZeroWeights
)

// New instantiate weight round-robin from portions PDF which is not necessarily 100%.
// The probability of occurrence of the index is calculated according to the weights
// of the individual elements in the PDF. If you have 30,10,20,40 or 3,1,2,4, the
// result will be the same
func New(pdf []uint32) (wrr *WS) {
	rand.Seed(time.Now().UnixNano())
	wrr = new(WS)
	wrr.pdf = make(touples, 0)
	for i, v := range pdf {
		wrr.balance += int(v)
		t := struct {
			index int
			value int
		}{index: i, value: int(v)}
		if v != 0 {
			wrr.filteredPDFFromZeroElements = append(wrr.filteredPDFFromZeroElements, t)
		}
		wrr.pdf = append(wrr.pdf, t)
	}
	return wrr
}

// PickVector returns slice shuffled by pdf distribution.
// The item with the highest probability will occur more often
// at the position that has the highest probability in the PDF
// see README.md
func (w *WS) PickVector(settings Settings) (indexes []int) {
	pdf := make(touples, len(w.filteredPDFFromZeroElements))
	copy(pdf, w.filteredPDFFromZeroElements)
	balance := w.balance
	for i := 0; i < len(pdf); i++ {
		cdf := w.getCDF(pdf)
		index := w.pick(cdf, balance)
		indexes = append(indexes, index)

		balance -= pdf[index].value
		pdf[index].value = 0
	}
	return w.indexes(settings, indexes)
}

// Pick returns one index with probability given by pdf
// see README.md
func (w *WS) Pick() (int, error) {
	if w.balance == 0 {
		return -1, fmt.Errorf("no index found for empty or zero-filled pdf ")
	}
	cdf := w.getCDF(w.pdf)
	return w.pick(cdf, w.balance), nil
}

// pick one index
func (w *WS) pick(cdf touples, n int) int {
	r := rand.Intn(n)
	index := 0
	for r >= cdf[index].value {
		index++
	}
	return index
}

func (w *WS) getCDF(pdf touples) (cdf touples) {
	// prepare cdf
	for i := 0; i < len(pdf); i++ {
		cdf = append(cdf, struct {
			index int
			value int
		}{index: 0, value: 0})
	}
	cdf[0] = pdf[0]
	for i := 1; i < len(pdf); i++ {
		cdf[i].value = cdf[i-1].value + pdf[i].value
	}
	return cdf
}

func (w *WS) indexes(settings Settings, calculatedIndexes []int) (indexes []int) {
	if len(calculatedIndexes) == len(w.pdf) {
		return calculatedIndexes
	}

	indexes = w.toPDFIndexes(calculatedIndexes)

	switch settings {
	case DropZeroWeights:
		return indexes
	case IncludeZeroWeights:
		for i := 0; i < len(w.pdf); i++ {
			apnd := true
			for _, v := range calculatedIndexes {
				if w.filteredPDFFromZeroElements[v].index == i {
					apnd = false
					break
				}
			}
			if apnd {
				indexes = append(indexes, i)
			}
		}
		return indexes
	default:
		return make([]int, 0)
	}
}

func (w *WS) toPDFIndexes(calculatedIndexes []int) (indexes []int) {
	for _, v := range calculatedIndexes {
		indexes = append(indexes, w.filteredPDFFromZeroElements[v].index)
	}
	return indexes
}
