package gows

/*
Copyright 2022 The k8gb Contributors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
Generated by GoLic, for more details see: https://github.com/AbsaOSS/golic
*/

import (
	"fmt"
	"math/rand"
	"time"
)

// WS Weight Round Robin Alghoritm
type WS struct {
	pdf                         touples
	filteredPDFFromZeroElements touples
}

type touples []struct {
	index      int
	percentage int
}

//The Settings argument defines how the PickVector function will return indexes
type Settings int

const (
	// KeepIndexesForZeroPDF keeps indexes for zero pdf elements.
	// e.g: for pdf=[0,50,50,0,0,0] may return [1,2,0,3,4,5] or [2,1,0,3,4,5]
	KeepIndexesForZeroPDF Settings = iota

	// IgnoreIndexesForZeroPDF filter indexes for zero pdf elements.
	// e.g: for pdf=[0,50,50,0,0,0] may return [1,2] or [2,1]
	IgnoreIndexesForZeroPDF
)

// NewWS instantiate weight round robin
func NewWS(pdf []int) (wrr *WS, err error) {
	r := 0
	wrr = new(WS)
	for i, v := range pdf {
		r += v
		if v < 0 || v > 100 {
			return wrr, fmt.Errorf("value %v out of range [0;100]", v)
		}
		t := struct {
			index      int
			percentage int
		}{i, v}
		if v != 0 {
			wrr.filteredPDFFromZeroElements = append(wrr.filteredPDFFromZeroElements, t)
		}
		wrr.pdf = append(wrr.pdf, t)
	}
	if r != 100 {
		return wrr, fmt.Errorf("sum of pdf elements must be equal to 100 perent")
	}
	rand.Seed(time.Now().UnixNano())
	return wrr, nil
}

// PickVector returns slice shuffled by pdf distribution.
// The item with the highest probability will occur more often
// at the position that has the highest probability in the PDF
// see README.md
func (w *WS) PickVector(settings Settings) (indexes []int) {
	pdf := make(touples, len(w.filteredPDFFromZeroElements))
	copy(pdf, w.filteredPDFFromZeroElements)
	balance := 100
	for i := 0; i < len(pdf); i++ {
		cdf := w.getCDF(pdf)
		index := w.pick(cdf, balance)
		indexes = append(indexes, index)

		balance -= pdf[index].percentage
		pdf[index].percentage = 0
	}
	return w.indexes(settings, indexes)
}

// Pick returns one index with probability given by pdf
// see README.md
func (w *WS) Pick() int {
	cdf := w.getCDF(w.pdf)
	return w.pick(cdf, 100)
}

// pick one index
func (w *WS) pick(cdf touples, n int) int {
	r := rand.Intn(n)
	index := 0
	for r >= cdf[index].percentage {
		index++
	}
	return index
}

func (w *WS) getCDF(pdf touples) (cdf touples) {
	// prepare cdf
	for i := 0; i < len(pdf); i++ {
		cdf = append(cdf, struct {
			index      int
			percentage int
		}{index: 0, percentage: 0})
	}
	cdf[0] = pdf[0]
	for i := 1; i < len(pdf); i++ {
		cdf[i].percentage = cdf[i-1].percentage + pdf[i].percentage
	}
	return cdf
}

func (w *WS) indexes(settings Settings, calculatedIndexes []int) (indexes []int) {
	if settings == IgnoreIndexesForZeroPDF {
		for _, v := range calculatedIndexes {
			indexes = append(indexes, w.filteredPDFFromZeroElements[v].index)
		}
		return indexes
	}
	for i := 0; i < len(w.pdf); i++ {
		indexes = append(indexes, i)
	}
	for i, v := range calculatedIndexes {
		indexes[i], indexes[w.filteredPDFFromZeroElements[v].index] = indexes[w.filteredPDFFromZeroElements[v].index], indexes[i]
	}
	return indexes
}
